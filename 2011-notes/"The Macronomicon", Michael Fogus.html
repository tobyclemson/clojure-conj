<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 3.0.2 (195746)"/><meta name="keywords" content="clojure, conference, day3"/><meta name="created" content="2011-11-12 10:59:30 -0500"/><meta name="updated" content="2011-11-12 11:41:58 -0500"/><title>"The Macronomicon", Michael Fogus</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
<b>Programs Writing Programs</b>
<ul>
<li>Code generation
<ul>
<li>XDoclet</li>
<li>XText</li>
<li>Lombock</li>
<li>Velocity, Erb</li>
<li>MDA</li>
<li>Rails</li>
<li>Hacks</li>
</ul>
</li>
<li>C
<ul>
<li>A long time ago, C had an interesting property: 
<ul>
<li>you could define macros that would replace any text in your program at compile time (preprocessor directives)</li>
<li>this caused problems</li>
<li>instead it evolved into a more constrained expression macro language</li>
</ul>
</li>
</ul>
</li>
<li>C++
<ul>
<li>Template metaprogramming
<ul>
<li>e.g., factorial</li>
<li>Bohm and Jacopini</li>
<li>values, functions, branching, recursion -> Turing completeness!</li>
</ul>
</li>
</ul>
</li>
<li>OCaml
<ul>
<li>From this: List.map (fun x -> x+1) [1; 2; 3;]</li>
<li>To: abstract syntax tree</li>
<li>The expander: &lt;:expr&lt; ... >></li>
</ul>
</li>
<li>Lisp
<ul>
<li>Lisp macros!</li>
<li>Use cases:
<ul>
<li>creating binding forms</li>
<li>creating control flow</li>
<li>icing</li>
</ul>
</li>
</ul>
</li>
</ul>
<b>History</b>
<ul>
<li>Lisp:
<ul>
<li>The original lisp eval...</li>
<li>AIM-57
<ul>
<li>Macro definitions in lisp</li>
<li>Timothy Harp</li>
</ul>
</li>
<li>Lightweight fn / blocks
<ul>
<li>control flow</li>
<li>bindings</li>
<li>e.g., Ruby</li>
</ul>
</li>
</ul>
</li>
<li>Scala
<ul>
<li>Baysick - Scala DSL for Basic :)</li>
</ul>
</li>
<li>Mapping Dilemma
<ul>
<li>One of the issues here is actually encapsulation: without macros the ability to create abstractions is limited by the degree to which underlying language constructs peek through the abstraction barrier</li>
</ul>
</li>
<li>Use cases:
<ul>
<li>...</li>
<li>"All legitimate uses of macros are legitimate" - Yogi Berra</li>
<li>Let's add:
<ul>
<li>Abstraction</li>
<li>Transformation (Houdini, biolerplate)</li>
<li>Optimisation</li>
<li>True power awesomeness!</li>
</ul>
</li>
</ul>
</li>
<li>What do you want?
<ul>
<li>A way to define local bindings</li>
<li>Properly scoped</li>
</ul>
</li>
<li>Do you need a macro?
<ul>
<li>e.g., function memoiser...didn't *really* need a macro so didn't use one</li>
</ul>
</li>
<li>What is it really?</li>
<li>Just start typing and it'll all work out fine!</li>
</ul>
<b>Hygiene</b>
<ul>
<li>An hygeinic macro is one where the meanings of symbols that aren't parameters to the macro are ...</li>
<li>Degenerative case 1
<ul>
<li>A macro that returns true when the value it is passed is true</li>
<li>Hygeinic as clean vs. unhygeinic as dirty or rotten</li>
</ul>
</li>
<li>Degenerative case 2
<ul>
<li>(defmaco awhen ...)</li>
<li>Hygeinic as sterile vs. Unhygeinic as getting things done</li>
</ul>
</li>
</ul>
<b>Use and Abuse of Macros</b>
<ul>
<li>Don't want to talk about DSLs</li>
<li>Instead let's talk about MSLs: mood specific languages</li>
<li>e.g., 
<ul>
<li>Trammel</li>
<li>Step 0: What did I want?
<ul>
<li>Goals
<ul>
<li>New :pre/:post syntax</li>
<li>Decomplected contracts</li>
<li>Invariants</li>
<li>...</li>
</ul>
</li>
</ul>
</li>
<li>Step 1: Do I need a macro?
<ul>
<li>Yes</li>
<li>Second class forms</li>
<li>Macros are first class at making second-class forms</li>
<li>Macros: why wait for Rich?!
<ul>
<li>He gave me the power and I'm going to abuse it...er I mean use it</li>
</ul>
</li>
</ul>
</li>
<li>Trammel is...
<ul>
<li>a new :pre / :post syntax</li>
<li>decomplected contracts
<ul>
<li>define a function, later on apply a contract to it</li>
</ul>
</li>
<li>record invariants</li>
<li>better error reporting</li>
</ul>
</li>
</ul>
</li>
</ul>
<b>Piecewise Transformation</b>
<ul>
<li>Disassemble a data structure that comes in</li>
<li>Incrementally manipulate it in pieces</li>
<li>Build back up into the thing the macro is producing</li>
<li>e.g.,
<ul>
<li>(as-futures ...)</li>
<li>actions distributed over a number of futures</li>
</ul>
</li>
<li>The nice thing is during the piecewise transformation you can attach functions that validate each piece and give more refined error handling</li>
</ul>
<b>What Lies Beneath...</b>
<ul>
<li>Build your macros on a solid foundation</li>
<li>Primacy of Semantics</li>
<li>A contract:
<ul>
<li>A function that takes a function and a number of arguments</li>
<li>Applies some pre and post conditions and then delegates to the underlying function</li>
</ul>
</li>
<li>Higher order function contracts
<ul>
<li>Can define a function that defines constraints on the function that it takes as an argument</li>
</ul>
</li>
</ul>
<b>The Cool Thing</b>
<ul>
<li>Using a single command it all goes away
<ul>
<li>(set! *assert* false)<br/></li>
</ul>
</li>
</ul>
<b>Programs Writing Programs Writing Programs</b>
<ul>
<li>Minderbinder</li>
<li>Inspired by Frink (http://futureboy.us)
<ul>
<li>deals with units and unit conversions in a precise way</li>
</ul>
</li>
<li>Unit conversions
<ul>
<li>just write a bunch of functions</li>
<li>keep typing</li>
<li>never stop typing</li>
<li>because there are so many different conversions!</li>
<li>"Ever feel like you're being boilerplated alive?"</li>
</ul>
</li>
<li>Boilerplate
<ul>
<li>The number of tasks against unicorns
<ul>
<li>first time you do a task it takes a lot of unicorns</li>
<li>second time it takes less unicorns</li>
<li>third time, look at automating, might cost more unicorns but it's worth it in the long run</li>
</ul>
</li>
</ul>
</li>
<li>e.g., length specification
<ul>
<li>first time just write all the functions</li>
<li>then wrap it in parenthesis and make it look like Clojure, end up with abstractions that mean you don't need to write so many functions!</li>
</ul>
</li>
<li>Primacy of syntax</li>
<li>Primacy of data</li>
<li>Mindbender
<ul>
<li>lets you just define the data and the conversions are implicit thanks to the macro</li>
<li>the macro does the calculation at compile time, the result of the macro is the result of the conversion</li>
</ul>
</li>
</ul>
<b>Learn More</b>
<ul>
<li>Books
<ul>
<li>...</li>
</ul>
</li>
<li>Links
<ul>
<li>...</li>
</ul>
</li>
</ul>
</body></html>