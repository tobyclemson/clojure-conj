<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 3.0.2 (195746)"/><meta name="keywords" content="clojure, conference, day2"/><meta name="created" content="2011-11-11 16:36:34 -0500"/><meta name="updated" content="2011-11-11 18:01:08 -0500"/><title>"Keynote: Areas of Interest for Clojure's Core", Rich Hickey</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
<b>Introduction</b>
<ul>
<li>This is not a roadmap!
<ul>
<li>This stuff may never make it into Clojure</li>
<li>Needs design time and effort</li>
<li>It's a bit half baked</li>
</ul>
</li>
</ul>
<b>Leaner</b>
<ul>
<li>Memory footprint</li>
<li>Startup time</li>
<li>Filesystem footprint</li>
<li>Why?
<ul>
<li>Delivering libraries written in Clojure to non-Clojure</li>
<li>Smaller targets, e.g., Android</li>
</ul>
</li>
<li>Move ASM out
<ul>
<li>Currently bundled in</li>
<li>Dynamic compilation only happens in the REPL</li>
<li>Unless your program calls (eval ...), no dynamic compilation happens in clojure.core</li>
<li>Adding rules to a running system is probably rare</li>
</ul>
</li>
<li>Dev-less builds
<ul>
<li>No metadata, shaking etc.
<ul>
<li>Need multiple build targets, currently have just one</li>
</ul>
</li>
<li>Debug builds
<ul>
<li>Could also go the other way and have bigger builds including more decoration of code<br/></li>
</ul>
</li>
</ul>
</li>
<li>Lisps traditionally have very good tool support</li>
</ul>
<b>Unification with ClojureScript</b>
<ul>
<li>ClojureScript is Clojure on a different host</li>
<li>Shared source libraries</li>
<li>Conditional compilation
<ul>
<li>Also needed by Clojure CLR</li>
</ul>
</li>
<li>Unifying on CLJS analysis rep for tooling
<ul>
<li>Potential for common tooling</li>
</ul>
</li>
<li>It has never been a goal of Clojure to be able to take an entire app and move it between hosts
<ul>
<li>That doesn't give you very much</li>
<li>However it does add lots of extra layers of abstraction over the hosts</li>
</ul>
</li>
<li>It would be nice to have a conditional knob to be able to choose what is compiled as ClojureScript and what is compiled as Clojure</li>
<li>"Looks like a lot for a human but it's nothing for a machine", comparing the ASTs for CLJS to those for Clojure</li>
</ul>
<b>Prepping for Clojure in Clojure (CinC)</b>
<ul>
<li>Move protocols down to the 'bottom'
<ul>
<li>directly emitted by compiler
<ul>
<li>currently require quite a lot of Clojure to be functional</li>
<li>high level macros</li>
</ul>
</li>
<li>value seen in ClojureScript
<ul>
<li>experimented with having (deftype ...), (defprotocol... ) etc. deeper down in ClojureScript</li>
<li>libraries and abstractions thus built on top of them</li>
<li>made it a pleasure to implement them</li>
</ul>
</li>
</ul>
</li>
<li>"Refactoring, I hate that word!"</li>
<li>Organising CLJS compiler for multiple targets?</li>
</ul>
<b>invokedynamic</b>
<ul>
<li>What it is
<ul>
<li>Code-gen and class-free call sites
<ul>
<li>Class is pretty big and carries lots of baggage, when each function requires a class, that gets expensive<br/></li>
</ul>
</li>
<li>Access to safe point 'magic'
<ul>
<li>A safe point is a magic implementation detail used during bytecode loading (?)<br/></li>
<li>Helps you to build tools to do dispatch without writing any extra code</li>
</ul>
</li>
</ul>
</li>
<li>For Clojure
<ul>
<li>protocol / keyword call sites
<ul>
<li>polymorphic call site dispatch</li>
</ul>
</li>
<li>fast + dynamic vars
<ul>
<li>var is an indirection and volatile</li>
<li>difficult to inline them when they become hot spots</li>
</ul>
</li>
<li>reflection-free interop
<ul>
<li>no need for type hints</li>
<li>one time only reflection, builds typed call sites</li>
<li>not in deep need but would be nice as a backup</li>
</ul>
</li>
</ul>
</li>
<li>Tradeoffs
<ul>
<li>Performance
<ul>
<li>should improve with more recent builds of Java 7</li>
</ul>
</li>
<li>Java 7 and above only, thus only in addition to what is already being done</li>
</ul>
</li>
</ul>
<b>Leveraging Logic</b>
<ul>
<li>code -> analysis -> core.logic
<ul>
<li>don't settle for 'type checking'</li>
<li>queryable programs</li>
</ul>
</li>
<li>predicate dispatch
<ul>
<li>don't settle for 'pattern matching'
<ul>
<li>"I don't like pattern matching"
<ul>
<li>it's closed</li>
<li>it's order dependant</li>
</ul>
</li>
<li>This means new patterns can't be added as the order of patterns is important</li>
<li>This goes away with predicate dispatch</li>
</ul>
</li>
<li>is core.logic fast enough for this?
<ul>
<li>precompile dispatch trees</li>
</ul>
</li>
</ul>
</li>
</ul>
<b>Parallelism</b>
<ul>
<li>Good concurrency support in place</li>
<li>Is fork/join framework the right thing for mixed (compute + I/O) models?</li>
<li>Is it the right thing for balanced compute models?
<ul>
<li>We can partition our system into I/O and compute on a case by case basis</li>
<li>However this isn't possible in the general case</li>
<li>Ideal when branching points lead to varying amounts of work</li>
</ul>
</li>
<li>Parallel algorithms, not collections
<ul>
<li>"We don't attach our functions to our data, we apply our functions to our data"</li>
<li>however, collections must have good 'shape'</li>
<li>seqs do not</li>
<li>we have parallel map and parallel reduce, would like to extend this to other operations</li>
</ul>
</li>
</ul>
<b>Transients and Beyond</b>
<ul>
<li>Transients do too much
<ul>
<li>Persistent symbiosis and editing</li>
<li><i>and</i> policy</li>
</ul>
</li>
<li>And too little
<ul>
<li>Users must use linearly</li>
</ul>
</li>
<li>Better to have a construct for this
<ul>
<li>Need to make sure the user doesn't have to be burdened with what they're doing</li>
</ul>
</li>
<li>Transient based model
<ul>
<li>Make into a transient in new memory (possible in constant time)</li>
<li>Apply procedures (possibly many) resulting in transients</li>
<li>Then make result persistent</li>
</ul>
</li>
<li>What about those transient -> transient procedures?
<ul>
<li>Might modify their arguments</li>
<li>Isn't this just icky mutable side effects?</li>
</ul>
</li>
</ul>
<b>Procedures</b>
<ul>
<li>Function of transient to transient</li>
<li>Like pure function, can't affect the world nor be affected by it</li>
<li>Only used in a context where transient cannot leak</li>
<li>Can always be sandwiched in value -> transient and transient -> value functions and become 'pure'</li>
</ul>
<b>Pods</b>
<ul>
<li>Split out policy from data structures</li>
<li>New policy:
<ul>
<li>value in, value out</li>
</ul>
</li>
<li>Process goes through the pod</li>
<li>Coherent process creates next value</li>
<li>Multiple options
<ul>
<li>single threaded</li>
<li>multi threaded access via mutex</li>
</ul>
</li>
<li>Work with transients
<ul>
<li>Just take policy out</li>
<li>Persistent map in, transient map inside, persistent map out</li>
</ul>
</li>
<li>Don't require persistent &lt;-> transient!
<ul>
<li>Can work with immutable &lt;-> mutable</li>
<li>String in, StringBuilder inside, String out</li>
<li>Provide a recipe for using ordinary Java stuff in a managed model</li>
</ul>
</li>
<li>The first construct that can apply to ordinary Java stuff</li>
<li>How do they look?
<ul>
<li>Wrap a pod around a persistent data structure: (pod [])</li>
<li>Send operations in: (>> ...)</li>
<li>System is extensible</li>
</ul>
</li>
</ul>
<b>Pod Power</b>
<ul>
<li>Pods allow process to extend across multiple functions and pods</li>
<li>Multi-threaded pods allow process to extend across cores
<ul>
<li>Pods can ensure lock acquisition problem</li>
<li>Pods can't fix the lock composition problem
<ul>
<li>but this can be detected</li>
</ul>
</li>
</ul>
</li>
<li>Pod based clone: @(pod x)</li>
<li>Pod peeking: (&lt;&lt; count some-pod)</li>
</ul>
<b>Pod Power</b>
<ul>
<li>Should internal pod representation be a function of value type?</li>
<li>Or should we allow user-specified pod contents?</li>
<li>Can pods be revisited after producing a value?
<ul>
<li>Possible but may not be desirable</li>
</ul>
</li>
<li>Pod groups, sentry sharing</li>
<li>Multithreaded pod API:
<ul>
<li>(in-pods [a b c] ...)</li>
</ul>
</li>
</ul>
<b>Accumulators</b><br/>
<ul>
<li>Pods...do too much?</li>
<li>Most use is building / birthing</li>
<li>Maybe all we need is conj! / append
<ul>
<li>making details internal</li>
</ul>
</li>
<li>Same front end for accumulators and queues and ...
<ul>
<li>hmm</li>
</ul>
</li>
</ul>
<b>Extensible Reader</b>
<ul>
<li>Why?
<ul>
<li>Clojure data is a great serialisation format</li>
<li>More types</li>
<li>"XML has X and we don't have X"</li>
<li>What do we do right now? All kinds of things to extend</li>
<li>Fewer types means less self-describing
<ul>
<li>forces us to use existing data types to represent other types</li>
<li>XML allows data types to be introduced</li>
</ul>
</li>
</ul>
</li>
<li>But
<ul>
<li>Less consensus on representations</li>
<li>Avoid wheel rebuilding</li>
</ul>
</li>
<li>Premise
<ul>
<li>Meet at semantics and print / read representation</li>
<li>Plug in desired programmatic type</li>
</ul>
</li>
<li>How
<ul>
<li>Tags</li>
<li>On other readables</li>
</ul>
</li>
<li>e.g.,Â 
<ul>
<li>#instant "1985-04-12T23:20:50.52z"</li>
<li>#ints [0 1 2 3 5 7]</li>
<li>#my.ns/foo {:bar 123 :baz [5 6 7]}</li>
</ul>
</li>
</ul>
<b>Questions</b>
<ul>
<li>Have you looked at YAML's tag format? It's very similar and might help with implementation ideas...
<ul>
<li>Yeah, I'm not claiming originality, I ripped it off from Erlang</li>
</ul>
</li>
<li>'*print-dup*' spits out classes and '#=' etc., how is this different?
<ul>
<li>It's about semantic meaning of data, not about specific implementation</li>
<li>'*print-dup*' will distinguish 'HashMap' from 'ArrayMap' whether you like it or not</li>
</ul>
</li>
<li>Where does agreement happen about what '#instant "foo"' will rehydrate to?
<ul>
<li>No agreement</li>
<li>Can't dictate data structures</li>
</ul>
</li>
<li>Have you looked at openmath?
<ul>
<li>Might be worth a look</li>
</ul>
</li>
<li>Can you elaborate on querying programs?
<ul>
<li>Simple things like how often do we call this function?</li>
<li>How deeply nested are calls function?</li>
<li>Have we ever called this will an open file in hand?</li>
<li>Program analysis stuff</li>
<li>Cross cutting concerns</li>
</ul>
</li>
<li>Conditional computation for targetting different platofrms - what about specifying an interface that implementations must implement?
<ul>
<li>Don't like that at all, you're talking about reifying environments</li>
</ul>
</li>
<li>Pods solve generating a value, how about iterating over a collection using mutability as a performance optimisation?
<ul>
<li>To do this you have to hand off the work of doing a job to something that knows the implementation details of the type being manipulated</li>
<li>Haskell does some stuff with stream fusion which is a good example of the type system helpingÂ </li>
</ul>
</li>
<li>Platform power, access to safe points, devless builds: what is the most predominant platform power?
<ul>
<li>we have great platform power</li>
<li>need to make things slightly more efficient whilst keeping all platform features</li>
</ul>
</li>
<li>You talked last year about the issue of resource management in the presence of laziness. Are you any closer to solving the issue?
<ul>
<li>lazy evaluation might e.g., hold onto resources until evaluation reifies and allows resources to release</li>
<li>problem is harder than I thought</li>
</ul>
</li>
</ul>
</body></html>