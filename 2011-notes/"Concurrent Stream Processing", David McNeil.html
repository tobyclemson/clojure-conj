<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 3.0.2 (195746)"/><meta name="keywords" content="clojure, conference, day1"/><meta name="created" content="2011-11-10 09:39:43 -0500"/><meta name="updated" content="2011-11-11 08:55:08 -0500"/><title>"Concurrent Stream Processing", David McNeil</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
<div><a href="%22Concurrent%20Stream%20Processing%22,%20David%20McNeil.resources/david-mcneil-concurrent-stream-processing.pdf">david-mcneil-concurrent-stream-processing.pdf</a><b><br/></b></div>
<div><b><br/></b></div>
<div><b>Background</b></div>
<ul>
<li>Been building a database query translation and federation product</li>
<li>Databases -> Concurrent stream processing -> result set</li>
</ul>
<b>Needed stream operations</b>
<ul>
<li><b>...</b></li>
</ul>
<b>Other Requirements</b>
<ul>
<li>Efficient<br/>
<ul>
<li>Parallel execution</li>
<li>Non blocking on source IO</li>
</ul>
</li>
<li>Robust
<ul>
<li>Exception Handling</li>
<li>...</li>
</ul>
</li>
<li>Manageable
<ul>
<li>...</li>
</ul>
</li>
</ul>
<b>Shoulders of Giants</b>
<ul>
<li>Oracle, Sun etc.</li>
</ul>
<b>UNIX</b>
<ul>
<li>Pipes:
<ul>
<li>Processes:
<ul>
<li>concurrent</li>
<li>separate address spaces</li>
<li>multi-threaded</li>
<li>stdin, stdout, stderr</li>
</ul>
</li>
<li>Pipes
<ul>
<li>asynchronous</li>
<li>buffered</li>
<li>EOF</li>
</ul>
</li>
<li>Operators
<ul>
<li>standard library</li>
<li>extensible</li>
</ul>
</li>
<li>All run in an execution environment that understands how they fit together</li>
</ul>
</li>
</ul>
<b>In Cloure</b><br/>
<ul>
<li>Pipes and Nodes
<ul>
<li>Clojure library</li>
<li>What syntax would we use to achieve this?</li>
<li>Just use s-exps to represent the process tree</li>
</ul>
</li>
<li>From the bottom up, how would we build this?
<ul>
<li>Pieces<br/>
<ul>
<li>Pipe writers<br/></li>
<li>Pipe receivers</li>
<li>Pipe callbacks</li>
<li>Pipe protocol - encapsulates these behaviours</li>
<li>Pipe multiplexer - join</li>
<li>Pipe tee - fork</li>
<li>Processing nodes
<ul>
<li>Input pipe</li>
<li>Output pipe</li>
<li>Processing node
<ul>
<li>state</li>
<li>concurrency</li>
<li>in/out/function</li>
</ul>
</li>
</ul>
</li>
<li>Chunks in pipes</li>
<li>Processing trees
<ul>
<li>fire lots of threads at each of these parts</li>
</ul>
</li>
</ul>
</li>
<li>Externally:
<ul>
<li>Data sources
<ul>
<li>database queries, files, whatever</li>
</ul>
</li>
<li>Result
<ul>
<li>output at the end of the pipe tree</li>
</ul>
</li>
</ul>
</li>
<li>Nodes:
<ul>
<li>Push and pull between producers and consumers</li>
</ul>
</li>
<li>Efficient use of worker threads?</li>
</ul>
</li>
<li>Java fork/Join - fork join pool</li>
<li>Higher level
<ul>
<li>Processes
<ul>
<li>consists of many pipes and nodes</li>
</ul>
</li>
<li>Memory
<ul>
<li>Pipes go onto the heap when dead</li>
<li>How do we handle low heap space?</li>
<li>Swap in buffered pipes</li>
</ul>
</li>
<li>Cancellations / Timeouts
<ul>
<li>Nodes can be shutdown</li>
</ul>
</li>
</ul>
</li>
<li>Stream expressions
<ul>
<li>Tree of pipes ending in clojure expressions</li>
<li>How to compile?</li>
<li>Work from bottom up</li>
</ul>
</li>
<li>Stream operators
<ul>
<li>Mirror clojure sequence operations</li>
<li>Can take parts of streams</li>
<li>Let operators allow working with results of streams in other streams</li>
</ul>
</li>
<li>Compiling vs. Evaluating
<ul>
<li>Stream expression compiler separate from stream expression evaluator</li>
<li>Compiling
<ul>
<li>zipper walks the tree</li>
<li>compile macro compiles each piece</li>
</ul>
</li>
</ul>
</li>
</ul>
<b>DSL Approach</b>
<ul>
<li>s-exps
<ul>
<li>produced via Clojure mechanisms</li>
<li>passed around as data</li>
</ul>
</li>
<li>unqualified symbols from operators</li>
<li>tree of know operators
<ul>
<li>avoid general code walking</li>
<li>user macros expand to know operators</li>
</ul>
</li>
<li>multiple operator implementations
<ul>
<li>some invoked via clojure...</li>
<li>...</li>
</ul>
</li>
<li>expressions do no eval to their final value</li>
</ul>
<b>Code Generation</b>
<ul>
<li>Effectively writing a database</li>
<li>Application generates a program to process each query</li>
</ul>
<b>Tuple Processing Expressions</b>
<ul>
<li>Working on defining higher level tuple operations</li>
</ul>
<b>Distributable Stream Processing</b>
<ul>
<li>Break process tree into parts</li>
<li>Evaluate each in a distributed manner</li>
</ul>
<br/>
</body></html>