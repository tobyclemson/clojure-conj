<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 3.0.2 (195746)"/><meta name="keywords" content="clojure, conference, day2"/><meta name="created" content="2011-11-11 08:55:35 -0500"/><meta name="updated" content="2011-11-11 09:38:34 -0500"/><title>"(Neal's) Master Plan for Clojure Enterprise Mindshare Domination", Neal Ford</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
<b>Background</b>
<div>
<ul>
<li>Get to talk to lots of CTOs and might be able to bring some perspective and context</li>
<li>Going to focus on mu rather than lambda, the coefficient of friction!</li>
</ul>
<div><b><br/></b></div>
<div><b>How do...</b></div>
<ul>
<li>things become popular?</li>
<li>you make things popular?</li>
<li>...</li>
</ul>
<div><b>How do things become popular?</b></div>
<div><b><br/></b></div>
<b>Rain down from the top</b><br/>
<ul>
<li>Build Your Own Technology Radar
<ul>
<li>The ThoughtWorks radar covers the technologies TW thinks are hot explaining some of the more controversial members</li>
<li>Technologies are organised in a ring with the outside being don't use (hold) and the center being should use (adopt)</li>
<li>Build 2 radars? One for developers, one for CTOs</li>
</ul>
</li>
<li>Litmus Test for Choosing A Technology
<ul>
<li>How do you determine the next big thing?</li>
<li>Developer radars and litmus tests are all over tha map</li>
</ul>
</li>
<li>CTO Litmus Tests
<ul>
<li>Must be able to hire tons of inexpensive developers</li>
<li>The flaw here is that often you can achieve the same or more with a small team of high skill developers as with dozens or hundreds of lower skill developers</li>
<li>This statement really means "I'm afraid"</li>
<li>Often choose the less effective but more industry standard approach</li>
<li>Need to mollify CTOs and make them less afraid of the idea</li>
<li>Get them to risk success instead of avoid failure</li>
</ul>
</li>
<li>How do we '#mollify'?
<ul>
<li>Create new Clojure-ists everywhere</li>
<li>Sponsor SICP user groups</li>
<li>Create a poignant guide</li>
<li>Lurk around schools!</li>
<li>Koan contests</li>
<li>Make Clojure commonplace - make it a building block people use without even knowing.</li>
</ul>
</li>
<li>CTOs don't fear lisp
<ul>
<li>They don't even know what lisp is!</li>
<li>They fear "different"</li>
</ul>
</li>
</ul>
</div>
<b>Sprout up organically from the bottom</b><br/>
<ul>
<li>Productivity Pirates
<ul>
<li>Don't care about cool tech, they care about getting stuff done as quickly as possible</li>
<li>Build tools that support productivity pirates, raise the productivity flag</li>
</ul>
</li>
<li>How do we '#hoist'?
<ul>
<li>Web framework (boring)</li>
<li>RESTful integration?</li>
<li>O/R mapping?</li>
<li>Rules engines?!?</li>
</ul>
</li>
<li>2 Ways:
<ul>
<li>Breaking and entering
<ul>
<li>e.g.,
<ul>
<li>Linux</li>
<li>Rails</li>
</ul>
</li>
<li>Forced their way into the enterprise</li>
<li>Very difficult to do, has to be incredibly compelling</li>
<li>Need to give the impression it's not too risky</li>
</ul>
</li>
<li>Cat burglary
<ul>
<li>Piggy back your techology in on the back of another technology</li>
<li>e.g.,
<ul>
<li>Ruby on the back of Cucumber</li>
<li>Groovy on the back of Gradle</li>
<li>XML on the back of [pretty much everything!]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>How do we '#camouflage'?
<ul>
<li>Make Clojure commonplace</li>
<li>Get the clojure.jar everywhere</li>
</ul>
</li>
</ul>
<b>How do you make something popular?</b>
<ul>
<li>Be like Fox news!Â </li>
<li>Propaganda: a form of communication that is aimed at influencing the attitude of a community towards some cause of position so as to benefit oneself or one's group<br/></li>
<li>How do we '#propagandise'?
<ul>
<li>Stay on message!
<ul>
<li>High performance</li>
<li>Simple, not easy</li>
<li>Clojure as a vision for software, not a language</li>
<li>[Pimp the knitted castle vs. lego castle!]</li>
</ul>
</li>
<li>Stay relatively positive
<ul>
<li>e.g., Charles Nutter with JRuby convinced the Ruby community</li>
</ul>
</li>
</ul>
</li>
</ul>
<b>How do you build a bridge to popularity?</b>
<ul>
<li>Bringing a gun to a knife fight!</li>
<li>We have Lisp!</li>
<li>'#packheat'
<ul>
<li>If you believe you have an advantage...</li>
<li>...prove it!</li>
</ul>
</li>
<li>How do we '#packheat'?
<ul>
<li>Know you enemies
<ul>
<li>Not agile</li>
<li>Not scala</li>
<li>It's the status quo</li>
</ul>
</li>
</ul>
</li>
<li>'#befriend'
<ul>
<li>Scala will be the Next Big Thing on the JVM because it fetishizes complexity exactly the way that Java developers are used to.</li>
</ul>
</li>
<li>How do we '#befriend'?
<ul>
<li>Sell
<ul>
<li>alternate language to Java</li>
<li>functional</li>
<li>dynamic</li>
</ul>
</li>
<li>Now we can talk Clojure</li>
<li>Celebrate Scala's success - "A rise in tide raises all ships"</li>
</ul>
</li>
<li>'#encapsulate'
<ul>
<li>Encapsulate the entire world, they're not going to build a bridge to you, you need to build a bridge to them</li>
</ul>
</li>
<li>How do we '#encapsulate'?
<ul>
<li>Wrapper everything?
<ul>
<li>Add a nicer API around, for instance, the Actor library in Scala</li>
<li>Similarly, wrap all the Java APIs in an idiomatic Clojure way</li>
</ul>
</li>
</ul>
</li>
</ul>
<b>Neal's Master Plan</b>
<ul>
<li>#packheat</li>
<li>#mollify</li>
<li>#propagandise</li>
<li>#encapsulate</li>
<li>#camouflage</li>
<li>#hoist</li>
<li>#befriend</li>
</ul>
<b>Success Stories</b>
<ul>
<li>Spring
<ul>
<li>started small</li>
<li>strategised - SpringSource</li>
<li>brought in people to solve the difficult problems</li>
<li>infiltrated!</li>
</ul>
</li>
</ul>
<b>Questions</b>
<ul>
<li>Why should we engage the enterprise? Is it a lost cause? Should we just focus on the small startups that are more likely to adopt?
<ul>
<li>The trouble is you don't get the same kind of penetration if you take that approach</li>
<li>As a community you need to decide whether you even want to penetrate the enterprise</li>
</ul>
</li>
<li>But if businesses are built using Clojure that might make it easier for enterprise to adopt...
<ul>
<li>Exactly, mollify.</li>
</ul>
</li>
<li>Is it really a social problem? Why not just build a tool that translates between Java and Clojure?
<ul>
<li>Please build one, I'll take it into all the enterprises I work in</li>
</ul>
</li>
<li>Ruby went in without any baggage in the 90s, how do we shed out Lisp baggage?
<ul>
<li>The people you need to sell to don't know about Lisp's baggage</li>
<li>The baggage isn't necessarily a bad thing</li>
<li>Separately, having all the infrastructure, tools and libraries available makes the baggage unimportant</li>
</ul>
</li>
<li>One of your first premises is that organisations want low cost people, Clojure doesn't align with that, how do we handle the inexpensive people problem?
<ul>
<li>We need to push the "get more done with smaller teams" argument</li>
<li>Ruby is helping in this respect since Ruby teams are usually smaller</li>
</ul>
</li>
<li>I think you're missing the point, organisations aren't going to fire all their existing people, they need to upskill them
<ul>
<li>Yes that's a good point, that's why you need to make Clojure-ists everywhere</li>
</ul>
</li>
<li>It's all nice and good wanting to be in the enterprise but we shouldn't forget that there's also tonnes of money there!
<ul>
<li>Exactly right, that's precisely what the Spring guys saw, make money, build more stuff</li>
</ul>
</li>
</ul>
</body></html>