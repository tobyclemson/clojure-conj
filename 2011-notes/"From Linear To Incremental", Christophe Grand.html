<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 3.0.2 (195746)"/><meta name="created" content="2011-11-11 11:51:49 -0500"/><meta name="updated" content="2011-11-11 16:29:07 -0500"/><title>"From Linear To Incremental", Christophe Grand</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
<div><b><a href="%22From%20Linear%20To%20Incremental%22,%20Christophe%20Grand.resources/christophe-grand-from-linear-to-incremental.pdf">christophe-grand-from-linear-to-incremental.pdf</a><br/></b></div>
<div><b><br/></b></div>
Background
<ul>
<li>In the beginning there was frustration</li>
<li>Why do I need to reparse a whole file when I make a minor edit?</li>
<li>Changing one symbol doesn't change any structure</li>
<li>...</li>
</ul>
<b>Consequences</b>
<ul>
<li>Simple edits should be incremental</li>
<li>O(log n) rebuilding the parent index</li>
<li>Recom...</li>
</ul>
<b>Incremental Parsing</b>
<ul>
<li>Definition:
<ul>
<li>Recompute the whole parse-tree at a fraction of the cose after an edit</li>
</ul>
</li>
<li>Overloaded term:
<ul>
<li>Restartable</li>
<li>Lazy restartable (Yi, Haskell editor)</li>
</ul>
</li>
</ul>
<b>What's a parser?</b>
<ul>
<li>Consumes a string, returns a tree</li>
<li>A reduction:
<ul>
<li>(get-tree (reduce parse-step init input))</li>
</ul>
</li>
<li>Many programs can be coerced into such a form</li>
</ul>
<b>It can't be that hard</b><br/>
<ul>
<li>Just another reduce
<ul>
<li>The proglem isn't specific to parsing</li>
</ul>
</li>
<li>Solve the general case
<ul>
<li>Famous last words</li>
</ul>
</li>
<li>(reduce parse-step init input*) knowing (reduce parse-step init input) and diff vetween input and input*</li>
</ul>
<b>Reduce considered slightly harmful</b>
<ul>
<li>Unconstrained fn = sequential computation</li>
<li>Detrimental to parallelism and incrementalism too</li>
<li><b><br/></b></li>
</ul>
<b>Incrementalism is parallelism with your former self</b><br/>
<div><b><br/></b></div>
<div><b>I &lt;3 Associativity</b></div>
<ul>
<li>Can let you change tree and balance it
<ul>
<li>(= (f (f a b) c) f a (f b c))</li>
</ul>
</li>
<li>Sad fact: most functions aren't associative
<ul>
<li>parse-step not associative
<ul>
<li>state * token -> state</li>
</ul>
</li>
<li>associative functions are A* x A*</li>
</ul>
</li>
<li>Have
<ul>
<li>(reduce f init [a b c d])</li>
</ul>
</li>
<li>Compose together:
<ul>
<li>#(f % a) #(f % b) #(f % c) #(f % d)</li>
</ul>
</li>
<li>(comp ...) is associative</li>
<li>Incremental yet?
<ul>
<li>Yes, but composition is incremental, not the actual computation</li>
</ul>
</li>
<li>init is constant, incrementalism presupposes things don't change that much</li>
<li>Memoise nodes, though not the map and compose</li>
<li>Better, but:
<ul>
<li>some computation is skipped ...</li>
<li>composition tree + memoized ...</li>
<li>much ado about nothing!</li>
</ul>
</li>
</ul>
<b>Refining memoization</b>
<ul>
<li>Once an item differs, the output differs</li>
<li>Subsequent memoized results aren't used</li>
<li>How to leverage past computations?</li>
<li>Need to look at the state passed around - function specific</li>
</ul>
<b>What's the function?</b>
<ul>
<li>A parser step fn!</li>
<li>Minimally fancy algorithm</li>
<li>LR + contextual tokenizer</li>
</ul>
<b>LR</b>
<div>
<ul>
<li>A pushdown automaton
<ul>
<li>One finite state machine </li>
<li>...</li>
</ul>
</li>
<li>Step:
<ul>
<li>current state change:
<ul>
<li>push / peek / pop on stacks</li>
</ul>
</li>
<li>deep stack items are ignored
<ul>
<li>note even read stack lengths are ignored too</li>
</ul>
</li>
<li>Depends only on:
<ul>
<li>...</li>
</ul>
</li>
</ul>
</li>
<li>What's in a stack?
<ul>
<li>stratified by construction
<ul>
<li>local importance near top</li>
<li>distant/ global imporance near cottom</li>
</ul>
</li>
</ul>
</li>
<li>Concluson
<ul>
<li>steps are not influenced that much by distant changes
<ul>
<li>As long as current state and enough stack</li>
</ul>
</li>
<li>top items don't change true from composition too
<ul>
<li>skipping several steps at once</li>
</ul>
</li>
</ul>
</li>
</ul>
<b>Stack Transplantation</b></div>
<div>
<ul>
<li>First call: in (abcdef)  -> out (zcdef)</li>
<li>Next call: new in (abcghij) + previous out (zcdef) -> new out (zcghij)</li>
</ul>
<b>Differential memoisation</b></div>
<div>
<ul>
<li>Like memoization but works for input resembling known inputs</li>
<li>Tweak memoised output to match new input</li>
<li>When input too different, call the actual function</li>
</ul>
<b>Transplantation</b></div>
<div>
<ul>
<li>Best case: everything is reused
<ul>
<li>runs in logarithmic time</li>
<li>incremental, at last!</li>
</ul>
</li>
<li>Worst case: restartable</li>
<li>Two functions are needed:
<ul>
<li>One to approximate dependencies between output and input</li>
<li>One to quickly compute a new output based on a new input matching dependencies of a known [in out] pair</li>
</ul>
</li>
<li>Totally dependent on the algorithm</li>
<li>So dependent on the algorithm that:
<ul>
<li>...</li>
</ul>
</li>
</ul>
<b>Dependencies</b></div>
<div>
<ul>
<li>I use side-effects
<ul>
<li>tracing operations on stacks</li>
<li>easy, fast, expedient</li>
<li>...</li>
</ul>
</li>
</ul>
<b>Inside the step function</b></div>
<div>
<ul>
<li>Stacks are made mutable
<ul>
<li>Reduces object churn</li>
</ul>
</li>
<li>Processes a chunk of text
<ul>
<li>Reduces memory overhead</li>
<li>Reduces &lt;&lt;context>> switches (persistant / mutable)</li>
</ul>
</li>
</ul>
<div><b>The buffer</b></div>
</div>
<ul>
<li>Parsley API
<ul>
<li>(parser options &amp; grammar)</li>
<li>(incremental-buffer parser)</li>
<li>(edit buffer offset length s) ;; composition</li>
<li>(parse-tree buffer) ;; actual composition</li>
</ul>
</li>
</ul>
<b>Composition tree</b>
<ul>
<li>Reasonably balanced: 2-3 tree
<ul>
<li>Leaves are partial functions</li>
<li>Internal nodes are compositions</li>
<li>All nodes know their length in order to find where to perform edits</li>
</ul>
</li>
<li>A finger-tree may fit but:
<ul>
<li>The 2-3 tree was easier</li>
<li>No need for privileged access to ends</li>
</ul>
</li>
<li>...</li>
</ul>
...
<div><br/></div>
<div><b>Demo</b></div>
<div><b><br/></b></div>
<div><b>What's next?</b></div>
<ul>
<li>Refine dependencies computation
<ul>
<li>Think hard how to mechanise that</li>
</ul>
</li>
<li>Try to incrementalise other parsing techniques (namely GLR)</li>
<li>Minor but practical feature: bridge with the Regex DSL</li>
<li>Make the emperative code less brutal</li>
<li>More caching strategies</li>
<li><br/></li>
</ul>
<div><br/></div>
</body></html>