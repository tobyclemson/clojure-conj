<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 3.0.2 (195746)"/><meta name="keywords" content="clojure, conference, day2"/><meta name="created" content="2011-11-11 09:39:04 -0500"/><meta name="updated" content="2011-11-11 10:25:18 -0500"/><title>"Predicate Dispatch", David Nolan</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
<b>Background</b>
<ul>
<li>There was an email a couple of years ago saying it would be nice if multimethods worked in a slightly different way</li>
<li>Rich replied that what was being talked about was very similar to predicate dispatch</li>
<li>This sparked interest</li>
</ul>
<b>core.logic</b>
<ul>
<li>Faithful miniKanren implementation based on William Byrd's dissertation</li>
<li>Performance oriented enhancements</li>
<li>Adds knowledge base facilities</li>
<li>cKanren enhancements coming up!</li>
</ul>
<b>Pattern Matching</b>
<ul>
<li>"alphaKanren and nominal logic programming"</li>
<li>I didn't like the pattern matching macro in the dissertation</li>
<li>"Compiling Pattern Matching to Good Decision Trees"</li>
<li>Lazy Pattern Matching</li>
<li>Craig Chambers "Efficient Predicate Dispatch"</li>
</ul>
<b>Predicate Dispatch</b>
<ul>
<li>Chambers (Self) &amp; Chan</li>
<li>Some details are hardwired</li>
<li>How to remove the hardwired details?</li>
<li>Will it be dog slow?</li>
<li>Lots of other challenges</li>
<li>Rich Hickey doesn't like pattern matching!</li>
<li>...</li>
<li>Then why bother?
<ul>
<li>This is not Java</li>
<li>If we're willing to do a bit of research, the language is malleable enough to add the feature yourself</li>
</ul>
</li>
</ul>
<b>Why Predicate Dispatch?</b>
<ul>
<li>What's wrong with multimethods?
<ul>
<li>They're really powerful :)</li>
<li>Don't use them often but they're nice to have when you do need them :)</li>
<li>The dispatch is hardwired :(
<ul>
<li>can't change that function in the future</li>
</ul>
</li>
</ul>
</li>
<li>Expressiveness, Simplicity and Power
<ul>
<li>Simple ideas are easy to adopt
<ul>
<li>Sophisticated ideas need a simple story to be impactful</li>
<li>"Deceptively simple"</li>
</ul>
</li>
<li>Sophisticated ideas still need simple interfaces</li>
<li>Doing things dynamically instead of statically can be really liberating</li>
</ul>
</li>
</ul>
<b>Is Predicate Dispatch Simple?</b>
<ul>
<li>Is open dispatch simpler than closed dispatch?</li>
<li>(defm ... [inner outer (form :when ...)] ...)</li>
<li>Winding roads to predicate dispatch</li>
<li>Pattern matching
<ul>
<li>rich history of papers in the mid 80s</li>
<li>key enhancement predicate dispatch offers is open extension</li>
</ul>
</li>
</ul>
<b>core.match</b>
<ul>
<li>Matches arguments against predefined structures to determine result</li>
<li>Each pattern type is handed all rows that match</li>
<li>Maps give random access in matching that lists don't</li>
<li>Closed -> open simalar to static -> dynamic</li>
</ul>
<div><b>Open Extension</b></div>
<ul>
<li>Pattern matching is top down</li>
<li>Open extension is not</li>
<li>even? implies 2
<ul>
<li>original paper hardwired numbers</li>
<li>can we avoid that?</li>
</ul>
</li>
<li>Inserting some (core) logic</li>
<li>But we don't want to break other people's code (namespace local changes?)</li>
<li>e.g.,<br/>
<ul>
<li>(defpred even? even?)</li>
<li>(defm foo [(x :when even?)] ...)</li>
<li>(defm foo [2] ...)</li>
</ul>
</li>
</ul>
<b>More Challenges</b>
<ul>
<li>core.match being closed is simple - generate the correct static source</li>
<li>Supporting dynamism - performant implementation no longer simpleÂ </li>
<li>If we change to a graph representation we lose the performance benefits of host branching primitives (if ... else)</li>
<li>Lazy compilation complicates targeting Clojurescript</li>
<li>We could emit the entire dispatch at each extension point - code size will suffer</li>
<li>Like deftype / protocols perhaps we could fully optimise all cases defined "together", future extension taking a reasonable performance hit</li>
<li>Grouped future extension receive shared performance benefits</li>
<li>What about redefinition? What about introspection?</li>
<li>Extension that require a reordeing - "game over", perhaps we emit the entire decision tree locally to the namespace?</li>
<li>Big idea: non-overlapping clauses</li>
<li>Other ideas / solutions / approaches</li>
<li>Wishful thinking is fun isn't it?! :)</li>
</ul>
<b>Questions</b>
<ul>
<li>Checkout Charles Forgey with Ops 5</li>
<li>Is it production ready?
<ul>
<li>No not at all!</li>
</ul>
</li>
</ul>
</body></html>